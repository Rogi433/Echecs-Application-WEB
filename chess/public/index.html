<!DOCTYPE html>

<html lang="fr">
<meta charset="utf-8">

<title>Echecs</title>

<style>


td {
	padding : 0.25vw;
	background-repeat: no-repeat;
	background-position: center;
	background-size: 2.5vw;
}

td:hover {
	border: 0.25vw solid red;
	padding:0;
}

div{
	align-content:center;
	
}

img{
	padding-left : 1vw;
}

#echiquier{
	border : solid black;
	margin : 0 5vw;
}

#promotion{
padding-top:1vw;
margin : 0 5vw;
width : 30vw;
text-align:center;
}

#chat{
	width : 40vw;
	
	border : solid black;
}

#chatContent{
	height : 22.5vw;
	overflow : auto;
	
}

</style>


<body>
<h1>Jeu d'échecs</h1>
<div id="contenu">
<p>Vous etes le joueur <span id="indication_joueur"></span></p>
<table id="echiquier" style="float:left"></table>

<div id="chat" style="float:left">Chat :<br/><hr/> <div id="chatContent"></div> </div>
  
 <div id="promotion" style="clear:left">Promotion :<br/><hr/></div></div>
 
 
 <div id="infoEchec" style="clear:left"></div>

</body>

<script src="/socket.io/socket.io.js"></script>
  
<script>

var board=[];

var socket = io();


socket.on('disconnect',function(){
	contenu.textContent="Vous etes déconnecté";
});

socket.on('init',function(couleur,data){
	joueur=couleur;
	if(joueur==1){
		indication_joueur.textContent="Blanc";
		board=JSON.parse(data);
		your_turn=true;
	}
	else{
		indication_joueur.textContent="Noir";
		board=convert(JSON.parse(data));
	}
	update();
});

socket.on('update',function(data){
	if(joueur==1){
		board=JSON.parse(data);
	}
	else{
		board=convert(JSON.parse(data));
	}
	update();
	your_turn=true;
});


//construction de la table correspondant a l'echiquier
var table=[];

for (let k=0;k<8;k++)
{

	
	let ligne=document.createElement("tr");
	let liste=[];
	
	for (let l=0;l<8;l++){
	
		let cell=document.createElement("td");
		if ((k+l)%2==1) cell.style.backgroundColor="rgb(255,200,160)";
		else cell.style.backgroundColor="white";
		
		cell.style.width="3vw";
		cell.style.height="3vw";
		
		
		cell.addEventListener('click',function(){selectCell(k,l)});
		
		ligne.appendChild(cell);
		liste.push(cell);
	}
	
	
	table.push(liste);
	
	echiquier.appendChild(ligne);
}


var current=undefined; //pour la selection de case cliquée

//construction de la zone de selection dans le cas de promotion de pion (au depart invisible)
for (let l=2;l<6;l++){
	
	let cell=document.createElement("td");
	
	img=document.createElement("img");
	img.src="images/"+l+".png";
	img.style.width="4vw";
	img.style.height="4vw";
	
	img.addEventListener('click',function(){choosePromotion(l)});
	
	br=document.createElement("br");
	
	//image='url("images/'+l+'.png")';
	//cell.style.backgroundImage=image;	
	//ligne_promotion.appendChild(cell);
	
	promotion.appendChild(img);
	//promotion.appendChild(br);
}
promotion.style.display="none";

var promotionSquare; //used when a promotion is being choosed

//partie de gestion du jeu

var joueur;//d'abord les blancs, vaudrait -1 pendant le tour des noirs
var your_turn=false;

var roquePossible=true;

const K=1; //pour rendre plus clair l'utilisation des codes avec par exemple K ou -K au lieu de 1 ou -1 pour un roi
const Q=2;
const B=3;
const N=4;
const R=5;
const P=6;

function promote(){
	promotion.style.display="block";
}

function message(text){
	let texte = document.createTextNode(text);
	let br = document.createElement("br");
	chatContent.appendChild(texte);
	chatContent.appendChild(br);
	chatContent.scrollTop = chatContent.scrollHeight;
}

function convert(old_board){//convertit de la vue du noir a celle du blanc et vice versa
	let new_board=[];
	for (let k=0;k<8;k++){
		new_board.push(new Array(8));
	}
	
	for (let k=0;k<8;k++){
			for (let l=0;l<8;l++){
				new_board[7-k][7-l]=old_board[k][l];
			}
		}
	return new_board;

}

function selectCell(k,l){
	console.log(k+","+l);
	
	if (your_turn){
		if (current==undefined){
			current=[k,l];
			cell=table[k][l];
			cell.style.backgroundColor="green";
		}
		else{
			let x=current[0];
			let y=current[1];
			current=undefined;
			cell=table[x][y];
			if ((x+y)%2==1) cell.style.backgroundColor="rgb(255,200,160)";
			else cell.style.backgroundColor="white";
			
			
			
			if (coup_ok(joueur,[x,y],[k,l])){
				
				
				board[k][l]=board[x][y];
				board[x][y]=0;
				
				update();
				
				if (Math.abs(board[k][l])==K){
					roquePossible=false; //le roi a bougé donc roque plus possible
				}
				
				if (k==0 && Math.abs(board[k][l])==P){//promotion
					promotion.style.display="block";
					promotionSquare=[k,l];
				}
				else{
				
					endTurn();
				
				}
				
				
			}
		}
	}
}

function update(){
	for (var k=0;k<8;k++){
		for (var l=0;l<8;l++){
		
			let piece=board[k][l];			
			let cell=table[k][l];
			if (piece!=0){
				image='url("images/'+piece+'.png")';
				cell.style.backgroundImage=image;
			}
			else{
				cell.style.backgroundImage="none";
			}
		}
	}
}

function deplacement_ok(camp,start,end){
	let x1=start[0];
	let y1=start[1];
	let x2=end[0];
	let y2=end[1];
	
	let piece1=board[x1][y1];
	let piece2=board[x2][y2];
	
	if (camp*piece1<=0){ 
		return false //si la case de depart est vide ou contient une piece de l'equipe qui ne joue pas
	}
	
	if (camp*piece2>0){ 
		return false //si la case de fin contient une piece de l'equipe qui joue
	}
	
	if (Math.abs(piece1)==P){ //cas du pion
		if (piece2==0 && y2==y1 && x2==x1-1){ //le pion doit toujours avancer vers le haut (puisque on affiche les pieces du joueur en bas et de l'ennemi en haut dans tous les cas)
			return true; //avancee normale d'une case
		}
		if (piece2==0 && y2==y1 && x1==6 && x2==x1-2){ 
			return true; //avancee de deux cases pour un pion au debut
		}
		if (piece2*piece1<0 && Math.abs(y2-y1)==1 && x2==x1-1){
			return true; //prise d'une piece ennemie
		}
		
		
	}
	
	if (Math.abs(piece1)==R){//cas de la tour
		if (y2==y1){ //déplacement vertical
			for (let x=Math.min(x1,x2)+1;x<Math.max(x1,x2);x++){ //pour vérifier que les cases intermediaires sont vides
				if (board[x][y1]!=0) return false;
			}
			return true;
		}
		if (x2==x1){ //déplacement horizontal
			for (let y=Math.min(y1,y2)+1;y<Math.max(y1,y2);y++){ //pour vérifier que les cases intermediaires sont vides
				if (board[x1][y]!=0) return false;
			}
			return true;
		}
	}
	
	if (Math.abs(piece1)==N){//cas du cheval
		if ((Math.abs(x1-x2)==2 && Math.abs(y1-y2)==1) || (Math.abs(x1-x2)==1 && Math.abs(y1-y2)==2)){//verification de 1 case dans un sens et 2 dans l'autre
			return true; //pas besoin de verifier des cases intermediaires ici
		}
	}
	
	if (Math.abs(piece1)==B){//cas du fou
		if (Math.abs(x1-x2)==Math.abs(y1-y2)){ //verification que le deplacement est diagonal
			for (let n=1;n<Math.abs(x1-x2);n++) { //pour vérifier que les cases intermediaires sont vides
				let x=x1+n*(x2-x1)/Math.abs(x2-x1);
				let y=y1+n*(y2-y1)/Math.abs(y2-y1);
				if (board[x][y]!=0) return false;
			}
			return true;			
		}
		
	}
	
	if (Math.abs(piece1)==Q){//cas de la reine (on reprend les parties de code du fou et de la tour)
	
		if (y2==y1){ //déplacement vertical
			for (let x=Math.min(x1,x2)+1;x<Math.max(x1,x2);x++){ //pour vérifier que les cases intermediaires sont vides
				if (board[x][y1]!=0) return false;
			}
			return true;
		}
		if (x2==x1){ //déplacement horizontal
			for (let y=Math.min(y1,y2)+1;y<Math.max(y1,y2);y++){ //pour vérifier que les cases intermediaires sont vides
				if (board[x1][y]!=0) return false;
			}
			return true;
		}
		
		if (Math.abs(x1-x2)==Math.abs(y1-y2)){ //verification que le deplacement est diagonal
			for (let n=1;n<Math.abs(x1-x2);n++) { //pour vérifier que les cases intermediaires sont vides
				let x=x1+n*(x2-x1)/Math.abs(x2-x1);
				let y=y1+n*(y2-y1)/Math.abs(y2-y1);
				if (board[x][y]!=0) return false;
			}
			return true;			
		}
		
	}
	
	if (Math.abs(piece1)==K){//cas du roi
		if ((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)<=2){//mouvement normal, le roque est verifie dans coup_ok
			return true;
		}
	}
	
	
	
	return false;

}

function reste_coup_possible(camp){ //verifie si il reste au moins un coup possible pour camp (camp = 1 pour le blanc ou -1 pour le noir)
	
	for (let x1=0;x1<8;x1++){
		for (let y1=0;y1<8;y1++) {
		
			if (board[x1][y1]*camp>0) {//piece de la bonne couleur
			
				for (let x2=0;x2<8;x2++){
					for (let y2=0;y2<8;y2++) {
						if (coup_ok(camp,[x1,y1],[x2,y2])) return true;				
					}
				}
			
			}
		
		
		}
	}
	
	return false;
}

function is_check(camp){ //verifie si il y a un echec menacant camp (camp = 1 pour le blanc ou -1 pour le noir)

	for (let x2=0;x2<8;x2++){
		for (let y2=0;y2<8;y2++) {
		
			if (board[x2][y2]==camp*K) {//roi de la bonne couleur
			
				for (let x1=0;x1<8;x1++){
					for (let y1=0;y1<8;y1++) {
						if (deplacement_ok(-camp,[x1,y1],[x2,y2])) return true;				
					}
				}
			
			}
		
		
		}
	}
	
	return false;	
}

function coup_ok(camp,start,end){

	let x1=start[0];
	let y1=start[1];
	let x2=end[0];
	let y2=end[1];
	
	let piece1=board[x1][y1];
	let piece2=board[x2][y2];

	//deplacement_ok verifie seulement les deplacements standards donc on verifie aussi le cas du roque
	let roque=false;
	if (Math.abs(piece1)==K && Math.abs(y2-y1)==2 && x1==x2 && roquePossible){
		
	}
	
	if (deplacement_ok(camp,start,end)){
		
		board[x2][y2]=piece1;
		board[x1][y1]=0;
		
		let check=is_check(camp);
		board[x1][y1]=piece1;
		board[x2][y2]=piece2;
		
		if (!check) return true;
			
		}
	
	//on verifie le cas du roque ici et pas dans deplacement_ok car il faut faire appel a deplacement_ok pour verifier les non-echecs
		
	return false;	
}

function choosePromotion(piece){
	x=promotionSquare[0];
	y=promotionSquare[1];
	
	board[x][y]=joueur*piece;
	update();
	
	promotion.style.display="none";
	
	endTurn();
}

function endTurn(){
	if(joueur==1){
		socket.emit('update',JSON.stringify(board));
	}
	else{
		socket.emit('update',JSON.stringify(convert(board)));
	}
					
	your_turn=false;
					
	if (is_check(1)) console.log("blanc menacé");
	if (is_check(-1)) console.log("noir menacé");
					
	if (!(reste_coup_possible(-joueur))){
		if (joueur==1) infoEchec.textContent="Blanc a gagné";
		else infoEchec.textContent="Noir a gagné";
	}
}

</script>
